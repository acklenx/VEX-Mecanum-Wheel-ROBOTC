#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    lineFollower1,  sensorLineFollower)
#pragma config(Sensor, in2,    lineFollower2,  sensorLineFollower)
#pragma config(Sensor, in3,    lineFollower3,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  bumpSwitchFront, sensorTouch)
#pragma config(Sensor, dgtl2,  sonarLeft,      sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  sonarRight,     sensorSONAR_inch)
#pragma config(Sensor, dgtl8,  sonarFront,     sensorSONAR_inch)
#pragma config(Sensor, dgtl10, sonarRear,      sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  motorIEC_RF,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  motorIEC_LF,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  motorIEC_RR,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  motorIEC_LR,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           motor_RF,      tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           motor_LF,      tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           motor_RR,      tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           motor_LR,      tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\                  *|
\*-----------------------------------------------------------------------------------------------4246-*/

// eliminates warning statements for unused functions
// in custom libraries
#pragma systemFile


//	THIS SECTION RESERVED FOR CUSTOM #include FILES
#include "HolonomicDrive.h"
//#include "LCDManager.h"
//#include "SentinalGlobals.h"

//==========================================================
//  FUNCTION DECLARATIONS
//==========================================================

// SENSORS
int frontBumperPressed();

// SYSTEM CHECKS
void checkSystemComponents();

// MODES
short remoteControlMode();
short trackLineMode();
short behavioralMode();
short discoveryMode();
short mappingMode();
short defensiveMode();

// ADMIN
task monitorSensors();

//===================================
// 		FUNCTION DEFINITIONS
//===================================

//==========================================================
//	frontBumperPressed
//	returns 0 if bumper not pressed
//	returns 1 if bumper pressed
//==========================================================
int frontBumperPressed()
{
	writeDebugStreamLine("frontBumperPressed");

	return SensorValue[bumpSwitchFront];
}

//==========================================================
//	checkSystemComponents
//
//
//==========================================================
void checkSystemComponents()
{
	writeDebugStreamLine("checkSystemComponents");

	resetMotorEncoders();

	// Check the Battery Level
	int nBatteryAverage = nAvgBatteryLevel;
	writeDebugStreamLine("Average Battery Level: %d", nBatteryAverage);
	int nBatteryLevel = nImmediateBatteryLevel;
	writeDebugStreamLine("Immediate Battery Level: %d", nBatteryLevel);

	// write to the sensor
	clearLCDLine(0);
	clearLCDLine(1);
	setLCDPosition(0,0);
	//displayNextLCDString("BATTERY: ");
	displayLCDString(0,0, "BATTERY: ");
	displayLCDNumber(0, 10, nBatteryLevel);

	wait1Msec(3000);

	return;
}

//==========================================================
//	remoteControlMode
//
//
//==========================================================
short remoteControlMode()
{
	writeDebugStreamLine("runRemoteControlMode");

	resetMotorEncoders();

	populateLCDMenu("REMOTE MODE", EXIT );

	// Create and initialize local variables used for
	// calculating each motor speed
	int powerRF = 0;
	int powerLF = 0;
	int powerRR = 0;
	int powerLR = 0;
	int thresholdPower = 15;

	while( true )
	{
		// Joystick: right stick moving forward/backward and right/left
		powerRF = vexRT[Ch2] - vexRT[Ch1];
		abs(powerRF) > thresholdPower ?
		motor[motor_RF] = powerRF :
		motor[motor_RF] = 0;

		// Joystick: left stick moving forward/backward and right/left
		powerLF = vexRT[Ch3] + vexRT[Ch4];
		abs(powerLF) > thresholdPower ?
		motor[motor_LF] = powerLF :
		motor[motor_LF] = 0;

		// Joystick: right stick moving forward/backward and right/left
		powerRR  = vexRT[Ch2] + vexRT[Ch1];
		abs(powerRR) > thresholdPower ?
		motor[motor_RR] = powerRR :
		motor[motor_RR] = 0;

		// Joystick: left stick moving forward/backward and right/left
		powerLR  = vexRT[Ch3] - vexRT[Ch4];
		abs(powerLR) > thresholdPower ?
		motor[motor_LR] = powerLR :
		motor[motor_LR] = 0;

		wait1Msec(PAUSETIME);

		if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
		{
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_REMOTECONTROL;
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2) // 2: Center button [EXIT] is pressed
		{
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_EXIT;
		}
	} // end while loop

	return MODE_EXIT;
} // end remoteControlMode


//==========================================================
//	trackLineMode
//	The VEX Line Tracking Sensor allows the robot to tell objects or surfaces apart
//	based on how dark or light they are. It shines a beam of infrared light out
//	onto the object, and measures how much light is reflected back.
//	The Line Tracking Sensor is an analog sensor.
// Values range from  0 to 4095.
//	Darker objects reflect less light, and are indicated by higher numbers.
//	Lighter objects reflect more light, and are indicated by lower numbers.
//   LIGHTER <- 0   SensorValue[lineFollowerN]   -> 4095  DARKER
//==========================================================
short trackLineMode()
{
	writeDebugStreamLine("trackLineMode");

	resetMotorEncoders();

	// LineFollower Sensors, left to right, looking from back of vehicle
	// 	lineFollower1  ... left
	// 	lineFollower2  ... middle
	//	lineFollower3 ... right
	//writeDebugStreamLine("trackLine speed=%d", 30);

	populateLCDMenu("TRACK LINE MODE ", EXIT);
	showLineFollowerValuesOnLCD();

	wait1Msec(1000);

	while(true)
	{
		// Show the Line Follower Values to the LCD
		showLineFollowerValuesOnLCD();

		wait1Msec(100); // wait slightly

		if( nLCDButtons == 1	|| listenJoystick() == 1 ) // 1. left button pressed
		{
			stopAllMotors();
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_TRACKLINE;
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2 )
		{
			stopAllMotors();
			wait1Msec(PAUSETIME); // wait slightly
			return MODE_EXIT;
		}

		// Begin line following routine ...


	} // end while loop

	stopAllMotors();
	return MODE_EXIT;
} // end trackLineMode

//==========================================================
//	behavioralMode
//  If something approaches from the rear of the robot, once
//  it crosses the DEFENSE_REAR_THRESHOLD distance value,
// 	the robot will rotate clockwise until it detects another
// 	object at its front that is less than DEFENSE_FRONT_THRESHOLD
//
//==========================================================
short behavioralMode()
{
	writeDebugStreamLine("behavioralMode");

	populateLCDMenu("BEHAVIORAL MODE ", EXIT);
	wait1Msec(PAUSETIME);

	while( true ) // Primary While loop
	{
		showSonarValuesOnLCD();
		//writeDebugStreamLine("SONAR: %d", sonarVal );

		// React to objects to the rear of robot
		// Secondary While Loop
		while( sonarRearValGlobal < DEFENSE_REAR_THRESHOLD )
		{
			// rotate clockwise to face the object that approached from the rea
			moveRotateClockWise( SPEED_ROTATE_DEFAULT, 0 );

			// refresh the LCD
			showSonarValuesOnLCD();

			// Listen for LCD and Joystick commands
			if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
			{
				wait1Msec(PAUSETIME); // slow things down a bit
				stopAllMotors();
				return MODE_BEHAVIORAL; // return to choice menu system
			}
			else if( nLCDButtons == 2 || listenJoystick() == 2 )
			{
				wait1Msec(PAUSETIME); // wait a tenth of a second
				stopAllMotors();
				return MODE_EXIT; // exit program
			}

			wait1Msec(PAUSETIME); // slow things down a bit

			// Object is no longer in rear of Robot
			if( sonarRearValGlobal > DEFENSE_REAR_THRESHOLD )
			{
				writeDebugStreamLine("1 sonarRearValGlobal > DEFENSE_REAR_THRESHOLD");

				// refresh the LCD
				showSonarValuesOnLCD();

				wait1Msec(PAUSETIME); // slow things down a bit

				// Listen for LCD and Joystick commands
				if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
				{
					wait1Msec(PAUSETIME); // slow things down a bit
					stopAllMotors();
					return MODE_BEHAVIORAL; // return to choice menu system
				}
				else if( nLCDButtons == 2 || listenJoystick() == 2 )
				{
					wait1Msec(PAUSETIME); // wait a tenth of a second
					stopAllMotors();
					return MODE_EXIT; // exit program
				}

				bool timerFlag = false;

				// Tertiary while loop
				// continue rotating untill something is in front
				// However, to prevent danger or rotating forever,
				//	we start a Timer and after 3 seconds,
				// robot will stop all motors
				while( sonarFrontValGlobal > DEFENSE_FRONT_THRESHOLD )
				{
					writeDebugStreamLine("sonarFrontValGlobal > DEFENSE_FRONT_THRESHOLD");

					// Enage timer mechanism to make sure we
					// stop this while loop in 3 seconds.
					if( timerFlag == false )
					{
						clearTimer(T1);
						timerFlag = true;
					}

					// if timerFlag has been set, then Timer has been
					// counting.
					// If more than 3 seconds has elapsed, then stop
					// all motors and exit loop because
					// robot is chasing a tail that is not there
					if( timerFlag )
					{
						if( time1[T1] > BEHAVIORAL_TIME_LIMIT )
						{
							stopAllMotors();
							// break out of Tertiary while loop
							break;
						}
					}
					// refresh the LCD
					showSonarValuesOnLCD();
					wait1Msec(PAUSETIME); // slow things down a bit

					// Listen for LCD and Joystick commands
					if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
					{
						wait1Msec(PAUSETIME); // slow things down a bit
						stopAllMotors();
						return MODE_BEHAVIORAL; // return to choice menu system
					}
					else if( nLCDButtons == 2 || listenJoystick() == 2 )
					{
						wait1Msec(PAUSETIME); // wait a tenth of a second
						stopAllMotors();
						return MODE_EXIT; // exit program
					}
				} // end Tertiary while loop because object is now in front

			} // end if

		} // end Secondary while loop

		// stop motors
		stopAllMotors();

		wait1Msec(PAUSETIME);

		// Listen for LCD and Joystick commands
		if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
		{
			wait1Msec(PAUSETIME); // slow things down a bit
			stopAllMotors();
			return MODE_BEHAVIORAL; // return to choice menu system
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2 )
		{
			wait1Msec(PAUSETIME); // wait a tenth of a second
			stopAllMotors();
			return MODE_EXIT; // exit program
		}

	} // end Primary while loop

	stopAllMotors();
	return MODE_EXIT;
} // end behavioralMode

//==========================================================
//	discoveryMode
//
//
//==========================================================
short discoveryMode()
{
	writeDebugStreamLine("discoveryMode");

	populateLCDMenu("DISCOVERY MODE  ", EXIT);

	wait1Msec(1000); // wait a tenth of a second

	/*  Enter an infinite loop and gather data from the sonar.
	Show the sonar data on the LCD.
	sonarFront
	*/
	while(true)
	{
		clearLCDLine(0);
		displayLCDString(0,0,"SONAR:");

		// Put the Sonar Value to the LCD (inches)
		showSonarValuesOnLCD();
		//writeDebugStreamLine("SONAR: %d", sonarVal );

		wait1Msec(PAUSETIME); // wait a tenth of a second

		if( nLCDButtons == 1 || listenJoystick() == 1 ) // 1. left button pressed
		{
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_DISCOVERY;
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2 )
		{
			wait1Msec(PAUSETIME); // wait a tenth of a second
			return MODE_EXIT;
		}
	} // end while loop

	return MODE_EXIT;
} // end discoveryMode

//==========================================================
//	mappingMode
//
//
//==========================================================
short mappingMode()
{
	writeDebugStreamLine("mappingMode");

	populateLCDMenu("MAPPING MODE    ", EXIT);

	while( true )
	{
		wait1Msec(PAUSETIME);

		if( nLCDButtons == 1 || listenJoystick() == 1 ) // 1. left button pressed
		{
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_MAPPING;
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2 )
		{
			wait1Msec(PAUSETIME); // wait a tenth of a second
			return MODE_EXIT;
		}
	} // end while loop

	stopAllMotors();
	return MODE_EXIT;

} // end mappingMode

//==========================================================
//	defensiveMode
//
// 	Robot will move away from objects that are less
//  than the threshold distances for
//	DEFENSE_FRONT_THRESHOLD
//	DEFENSE_REAR_THRESHOLD
//	DEFENSE_RIGHT_THRESHOLD
//	DEFENSE_LEFT_THRESHOLD
//
//==========================================================
short defensiveMode()
{
	writeDebugStreamLine("defensiveMode");

	// declare boolean alert variables
	// assume nothing detected on any side.
	bool bObjectFront = false;
	bool bObjectRear 	= false;
	bool bObjectRight = false;
	bool bObjectLeft 	= false;

	populateLCDMenu("DEFENSIVE MODE  ", EXIT);
	showSonarValuesOnLCD();

	// Begin the infinite loop, which analyzes
	// if objects are too close to the front
	// or rear (or both front & rear) of robot
	while( true )
	{
		showSonarValuesOnLCD();

		// First, handle cases of front and rear proximity
		// Stuck Mode
		// Close objects detected in both front and rear
		if( sonarFrontValGlobal < DEFENSE_FRONT_THRESHOLD &&
			sonarRearValGlobal < DEFENSE_REAR_THRESHOLD )
		{
			bObjectFront = true;
	 		bObjectRear = true;
			//bObjectRight = false;
			//bObjectLeft = false;

			showSonarValuesOnLCD();

	 		if( bObjectRight == false &&
	 				bObjectLeft == false )
	 		{
				stopAllMotors();
			}
		}
		// Object detected too close to front
		else if( sonarFrontValGlobal < DEFENSE_FRONT_THRESHOLD )
		{
			bObjectFront 	= true;
	 		bObjectRear 	= false; // this may not be correct
			//bObjectRight = false;
			//bObjectLeft = false;

			showSonarValuesOnLCD();

			// Backup, indefinitely
			moveBackwardReact(	SPEED_REAR_DEFAULT );
		}
		// Object detected too close to rear
		else if( sonarRearValGlobal < DEFENSE_REAR_THRESHOLD )
		{
			bObjectFront 	= false;
	 		bObjectRear 	= true;
			//bObjectRight = false;
			//bObjectLeft = false;

			showSonarValuesOnLCD();

			// move forward
			moveForwardReact( SPEED_FRONT_DEFAULT );
		}
		// Robot is safe distance from objects both
		// front and rear
		else
		{
			// no objects were detected front or rear
			bObjectFront 	= false;
	 		bObjectRear 	= false;

	 		if( bObjectRight == false &&
	 				bObjectLeft == false )
	 		{
	 			// no objects detected anywhere, so it
	 			// is ok to stop all motors
				showSonarValuesOnLCD();
				stopAllMotors();
			}
		}

		// Now handle cases for left & right proximity
		if( sonarRightValGlobal < DEFENSE_RIGHT_THRESHOLD &&
						sonarLeftValGlobal < DEFENSE_LEFT_THRESHOLD)
		{
			//bObjectFront = false;
	 		//bObjectRear = false;
			bObjectRight 	= true;
			bObjectLeft 	= true;

			showSonarValuesOnLCD();

			if( bObjectFront == false &&
					bObjectRear == false )
			{
				stopAllMotors();
			}
		}
		// Object detected too close to right side
		else if( sonarRightValGlobal < DEFENSE_RIGHT_THRESHOLD )
		{
			//bObjectFront = false;
	 		//bObjectRear = false;
			bObjectRight = true;
			bObjectLeft = false;

			showSonarValuesOnLCD();

			// Backup, indefinitely
			moveTraverseLeftReact(	SPEED_LEFT_DEFAULT );
		}
		// Object detected too close to left side
		else if( sonarLeftValGlobal < DEFENSE_LEFT_THRESHOLD )
		{
			//bObjectFront = false;
	 		//bObjectRear = false;
			bObjectRight = false;
			bObjectLeft = true;
			showSonarValuesOnLCD();

			// move forward
			moveTraverseRightReact( SPEED_RIGHT_DEFAULT );
		}
		// Robot is safe distance from objects both
		// right and left
		else
		{
			if( bObjectFront == false &&
					bObjectRear == false )
			{
				showSonarValuesOnLCD();
				stopAllMotors();
			}
		}

		// normal pause time
		wait1Msec(PAUSETIME);

		// Check for User Input from LCD and Joystick
		if( nLCDButtons == 1 || listenJoystick() == 1) // 1. left button pressed
		{
			stopAllMotors();
			wait1Msec(PAUSETIME); // slow things down a bit
			return MODE_DEFENSIVE;
		}
		else if( nLCDButtons == 2 || listenJoystick() == 2)
		{
			stopAllMotors();
			wait1Msec(PAUSETIME); // wait a bit
			return MODE_EXIT;		// exit out of this function
		}

	} // end while

	// if we jumped out of the while loop for some reason,
	// then exit function
	stopAllMotors();
	return MODE_EXIT;

} // end defensiveMode


//==========================================================
//	0
//  Constantly runs and gets values from the named
//  sensors
//
//==========================================================
task monitorSensors()
{
	writeDebugStreamLine("task monitorSensors started");

	while( true )
	{
		// get the Sonar Values
		sonarFrontValGlobal = SensorValue[sonarFront];
		sonarRearValGlobal 	= SensorValue[sonarRear];
		sonarRightValGlobal = SensorValue[sonarRight];
		sonarLeftValGlobal 	= SensorValue[sonarLeft];

		// get the Line Follower Values
		lineFollower1ValGlobal = SensorValue[lineFollower1];
		lineFollower2ValGlobal = SensorValue[lineFollower2];
		lineFollower3ValGlobal = SensorValue[lineFollower3];

		bFrontBumperPressed = SensorValue[bumpSwitchFront];

		/**
		if( ROBOT_MODE == MODE_REMOTECONTROL ||  ROBOT_MODE == MODE_DRIVETEST )
		{
		// call function from LCDManager.showIECValuesOnLCD()
		// need to start a task, which samples the IEC values
		//showIECValuesOnLCD(motorIEC_RF);
		writeDebugStreamLine("motorIEC_RF %d ",
		getMotorEncoder(motor_RF) );
		writeDebugStreamLine("motorIEC_LF %d ",
		getMotorEncoder(motor_LF) );
		writeDebugStreamLine("motorIEC_RR %d ",
		getMotorEncoder(motor_RR) );
		writeDebugStreamLine("motorIEC_LR %d ",
		getMotorEncoder(motor_LR) );

		wait1Msec(500);
		} // end if
		*/

		wait1Msec(50);

	} // end while
}// end monitorSensors

//==========================================================
//	main
//
//
//==========================================================
task main()
{
	writeDebugStreamLine("main");

	// instance variabless

	// LCD Initialization Line
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	setLCDPosition(0,0);
	displayLCDCenteredString(0, "SENTINAL");
	setLCDPosition(1,0);

	wait1Msec(100);
	for( int i = 0; i < 15; i++)
	{
		displayNextLCDChar('.');
		wait1Msec(50);
	} // end for loop

	// Start Task of monitoring the Motor IECs
	startTask(monitorSensors);

	checkSystemComponents();



	// Start the LCD Menu choices and let user decide what to do
	//short mode = displayLCDChoice_Initial();
	ROBOT_MODE = displayLCDChoice_Initial();
	bool firstTime = true;

	while(true)
	{

		if(firstTime)
		{
			firstTime = false;
		}

		// If not first time through loop, then we can call the
		// displayLCDChoice_XXX functions
		// This puts the LCD back into a user decision making mode
		if(!firstTime)
		{
			switch(ROBOT_MODE)
			{
			case MODE_REMOTECONTROL:
				ROBOT_MODE = displayLCDChoice_Initial();
				break;
			case MODE_DRIVETEST:
				ROBOT_MODE = displayLCDChoice_DriveTest();
				break;
			case MODE_TRACKLINE:
				ROBOT_MODE = displayLCDChoice_TrackLine();
				break;
			case MODE_BEHAVIORAL:
				ROBOT_MODE = displayLCDChoice_Behavioral();
				break;
			case MODE_DISCOVERY:
				ROBOT_MODE = displayLCDChoice_Discovery();
				break;
			case MODE_MAPPING:
				ROBOT_MODE = displayLCDChoice_Mapping();
				break;
			case MODE_DEFENSIVE:
				ROBOT_MODE = displayLCDChoice_Defensive();
				break;
			case MODE_DECIDING:
				ROBOT_MODE = displayLCDChoice_Initial();
				break;
			default:
				ROBOT_MODE = MODE_EXIT;
				break;
			} // end switch
		} // end if firstTime check

		switch(ROBOT_MODE)
		{
			case MODE_REMOTECONTROL:
				ROBOT_MODE = remoteControlMode();
				break;
			case MODE_DRIVETEST:
				ROBOT_MODE = runDrivingTestBasic(	40, //SPEED_FRONT_DEFAULT,
																					0, // run time
																					2000, // pauses
																					true, true, true, true,
																					//true, false, false, false,
																					12.0 ); // distance inches
																					break;
			case MODE_TRACKLINE:
				ROBOT_MODE = trackLineMode();
				break;
			case MODE_BEHAVIORAL:
				ROBOT_MODE = behavioralMode();
				break;
			case MODE_DISCOVERY:
				ROBOT_MODE = discoveryMode();
				break;
			case MODE_MAPPING:
				ROBOT_MODE = mappingMode();
				break;
			case MODE_DEFENSIVE:
				ROBOT_MODE = defensiveMode();
				break;
			case MODE_DECIDING:
				ROBOT_MODE = displayLCDChoice_Initial();
				break;
			default:
				ROBOT_MODE = MODE_EXIT;
				break;
		} // end switch

		if(ROBOT_MODE == MODE_EXIT)
		{
			break; // break out of the infinite while loop
		}
	} // end while loop

	// Cleanup and Shutdown Procedure
	stopAllMotors();
	resetMotorEncoders();

	// LCD Goodbye Message
	populateLCDMenu("     GOODBYE    ", EMPTY);
	wait1Msec(2000);
	bLCDBacklight = false;

} // end main
